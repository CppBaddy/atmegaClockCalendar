//------------------------------------------------------------------------------
// This is Open source software. You can place this code on your site, but don't
// forget a link to my YouTube-channel: https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Это программное обеспечение распространяется свободно. Вы можете размещать
// его на вашем сайте, но не забудьте указать ссылку на мой YouTube-канал 
// "Электроника в объектике" https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Автор: Надыршин Руслан / Nadyrshin Ruslan
//------------------------------------------------------------------------------
#include <avr/io.h>
//#include <inavr.h>
#include <avr/interrupt.h>
#include "spim.h"


spi_endhandler spi_endfunc;

static uint8_t *pSPI_TxBuff;
static uint8_t *pSPI_RxBuff;
uint16_t spim_Len;
uint8_t spim_IsBisy = 0;

//==============================================================================
// Процедура инициализации spi в режиме master
//==============================================================================
void spim_init(void)
{
  // Настраиваем ножки сигналов SCK и MOSI. Их расположение перенастроить у AVR нельзя
  DDRB |= (_BV(DDB2) | _BV(DDB3) | _BV(DDB5));
  
  // Для ST7920 частота SPI не более 2.5 МГц, CPOL=1, CPHA=1
  SPCR |= _BV(SPE) | _BV(MSTR) | _BV(CPOL) | _BV(CPHA);// | _BV(SPR0);
  //SPSR |= (1 << SPI2X);
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов
//==============================================================================
void SPI_send8b(uint8_t *pBuff, uint16_t Len)
{
  SPI_SendRecv(pBuff, 0, Len);
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов с использованием прерываний SPI
//==============================================================================
void SPI_send8b_irq(uint8_t *pBuff, uint16_t Len, void (*func)(void))
{
  SPI_SendRecv_irq(pBuff, 0, Len, func);
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов
//==============================================================================
void SPI_recv8b(uint8_t *pBuff, uint16_t Len)
{
  SPI_SendRecv(0, pBuff, Len);
}
//==============================================================================


//==============================================================================
// Процедура принимает массив 8-битных слов с использованием прерываний SPI
//==============================================================================
void SPI_recv8b_irq(uint8_t *pBuff, uint16_t Len, void (*func)(void))
{
  SPI_SendRecv_irq(0, pBuff, Len, func);
}
//==============================================================================


//==============================================================================
// Процедура отправляет 1 байт и возвращает принятый байт
//==============================================================================
uint8_t SPI_SendRecvByte(uint8_t TxByte)
{
  spim_IsBisy = 1;

  SPDR = TxByte;
  while(!(SPSR & (1<<SPIF)));
  
  spim_IsBisy = 0;
  
  return SPDR;
}
//==============================================================================


//==============================================================================
// Процедура отправляет/принимает массив 8-битных слов
//==============================================================================
void SPI_SendRecv(uint8_t *pTxBuff, uint8_t *pRxBuff, uint16_t Len)
{
  if (((!pTxBuff) && (!pRxBuff)) || (!Len))
    return;
  
  spim_IsBisy = 1;

  for (uint16_t i = 0; i < Len; ++i)
  {
    SPDR = (pTxBuff) ? *(pTxBuff++) : 0xFF;
    while(!(SPSR & (1<<SPIF)));

    if (pRxBuff)
      *(pRxBuff++) = SPDR;
    else
      (void) SPDR;
  }
  
  spim_IsBisy = 0;
}
//==============================================================================


//==============================================================================
// Процедура отправляет/принимает массив 8-битных слов с использованием прерываний
//==============================================================================
void SPI_SendRecv_irq(uint8_t *pTxBuff, uint8_t *pRxBuff, uint16_t Len, void (*func)(void))
{
  if (((!pTxBuff) && (!pRxBuff)) || (!Len))
    return;
  
  // Запоминаем указатель на функцию, которую нужно будет вызвать по окончанию приёмо-передачи по SPI
  spi_endfunc = func;

  spim_IsBisy = 1;
  
  pSPI_TxBuff = pTxBuff;
  pSPI_RxBuff = pRxBuff;
  spim_Len = Len;
  
  // Включаем прерывания от SPI
  SPCR |= (1 << SPIE);
  // Сбрасываем флаги прерываний
  (void) SPSR;

  // Выдаём первый байт, остальные будем выдавать в обработчике прерывания
  SPDR = (pSPI_TxBuff) ? *(pSPI_TxBuff++) : 0xFF;
}
//==============================================================================


//==============================================================================
// Обработчик прерывания SPI
//==============================================================================
ISR( SPI_STC_vect )
{
  if (pSPI_RxBuff)
    *(pSPI_RxBuff++) = SPDR;
  else
    (void) SPDR;
 
  if (--spim_Len) // Есть ещё данные на передачу
    SPDR = (pSPI_TxBuff) ? *(pSPI_TxBuff++) : 0xFF;
  else          // Все данные переданы
  {
    spim_IsBisy = 0;

    // Отключаем прерывания от SPI
    SPCR &= ~(1 << SPIE);

    if (spi_endfunc)    // Функция окончания передачи была назначена при инициализации SPI
      spi_endfunc();    // Вызываем функцию
  }
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 16-битных слов
//==============================================================================
void SPI_send16b(uint16_t *pBuff, uint16_t Len)
{
  spim_IsBisy = 1;
  
  for (uint16_t i = 0; i < Len; i++)
  {
    // Выдаём старший байт
    SPDR = (*pBuff) >> 8; 
    while (!(SPSR & (1 << SPIF)))  {}
    // Выдаём младший байт
    SPDR = (*pBuff) & 0xFF; 
    while (!(SPSR & (1 << SPIF)))  {}
    
    pBuff++;
  }
  
  spim_IsBisy = 0;
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 16-битных слов
//==============================================================================
void SPI_recv16b(uint16_t *pBuff, uint16_t Len)
{
  uint16_t tmp;

  spim_IsBisy = 1;
  
  for (uint16_t i = 0; i < Len; i++)
  {
   SPDR = 0xFF;
   while(!(SPSR & (1<<SPIF)));
   tmp = (SPDR << 8);
   SPDR = 0xFF;
   while(!(SPSR & (1<<SPIF)));
   tmp |= SPDR;
   
   *(pBuff++) = tmp;
  }
  
  spim_IsBisy = 0;
}
//==============================================================================
